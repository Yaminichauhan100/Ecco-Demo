"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatabaseRepository = void 0;
const service_1 = require("../service");
const exceptions_1 = require("../exceptions");
class DatabaseRepository {
    constructor() {
        this.knexConnection = null;
    }
    bindCon(conName) {
        const newRepository = new (this.constructor)();
        const connection = service_1.ObjectionService.connection(conName || this.model.connection);
        newRepository.knexConnection = connection;
        return newRepository;
    }
    setModel(model) {
        this.model = model;
        return this;
    }
    all() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.query();
        });
    }
    firstWhere(inputs, error = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.query();
            const model = yield query.findOne(inputs);
            if (error && !model)
                this.raiseError();
            return model;
        });
    }
    getWhere(inputs, error = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.query();
            for (const key in inputs) {
                Array.isArray(inputs[key])
                    ? query.whereIn(key, inputs[key])
                    : query.where(key, inputs[key]);
            }
            const models = yield query;
            if (error && models.length == 0)
                this.raiseError();
            return models;
        });
    }
    create(inputs) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.query().insert(inputs).returning("*");
        });
    }
    createOrUpdate(conditions, values) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = yield this.firstWhere(conditions, false);
            if (!model) {
                return this.create(Object.assign(Object.assign({}, conditions), values));
            }
            yield this.update(model, values);
            return yield this.firstWhere(conditions, false);
        });
    }
    firstOrNew(conditions, values) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = yield this.firstWhere(conditions, false);
            if (model)
                return model;
            return yield this.create(Object.assign(Object.assign({}, conditions), values));
        });
    }
    update(model, setValues) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.query();
            query.findById(model.id).patch(setValues);
            return yield query;
        });
    }
    updateWhere(where, setValues) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.query();
            query.where(where).patch(setValues);
            return query;
        });
    }
    exists(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.query();
            query.where(params);
            return !!(yield query.onlyCount());
        });
    }
    count(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.query();
            query.where(params);
            return yield query.onlyCount();
        });
    }
    delete(model) {
        return __awaiter(this, void 0, void 0, function* () {
            return !!+(yield this.query().deleteById(typeof model != "object" ? model : model.id));
        });
    }
    deleteWhere(inputs) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.query();
            for (const key in inputs) {
                Array.isArray(inputs[key])
                    ? query.whereIn(key, inputs[key])
                    : query.where(key, inputs[key]);
            }
            return !!+(yield query.delete());
        });
    }
    refresh(model) {
        return __awaiter(this, void 0, void 0, function* () {
            return model ? yield this.query().findById(model.id) : undefined;
        });
    }
    attach(model, relation, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            yield model.$relatedQuery(relation).relate(payload);
            return;
        });
    }
    sync(model, relation, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            yield model.$relatedQuery(relation).unrelate();
            if (Array.isArray(payload) && payload.length > 0) {
                yield model.$relatedQuery(relation).relate(payload);
            }
            return;
        });
    }
    chunk(where, size, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.query();
            query.where(where);
            yield query.chunk(cb, size);
            return;
        });
    }
    raiseError() {
        throw new exceptions_1.ModelNotFound(this.getEntityName() + " not found");
    }
    query() {
        if (!this.knexConnection) {
            this.knexConnection = service_1.ObjectionService.connection(this.model.connection);
        }
        return this.model.query(this.knexConnection);
    }
    getEntityName() {
        return this.model.name;
    }
    updateAndReturn(where, setValues) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.query();
            const records = yield query.where(where).patch(setValues).returning("*");
            if (records.length == 1)
                return records[0];
            return records;
        });
    }
    bulkInsert(inputs) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.query().insert(inputs).returning("*");
        });
    }
}
exports.DatabaseRepository = DatabaseRepository;
