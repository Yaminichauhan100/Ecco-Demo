import { RepositoryContract } from "./contract";
import { BaseModel } from "../baseModel";
import { CustomQueryBuilder } from "../queryBuilder";
import { ModelKeys } from "../interfaces";
import { Knex as KnexType } from "knex";
export declare class DatabaseRepository<T extends BaseModel> implements RepositoryContract<T> {
    model: any;
    knexConnection: KnexType | null;
    bindCon(conName?: string): DatabaseRepository<T>;
    setModel(model: BaseModel): this;
    all(): Promise<T[]>;
    firstWhere(inputs: ModelKeys<T>, error?: boolean): Promise<T | undefined>;
    getWhere(inputs: ModelKeys<T>, error?: boolean): Promise<T[]>;
    create(inputs: ModelKeys<T>): Promise<T>;
    createOrUpdate(conditions: ModelKeys<T>, values: ModelKeys<T>): Promise<T | undefined>;
    firstOrNew(conditions: ModelKeys<T>, values: ModelKeys<T>): Promise<T>;
    update(model: T, setValues: ModelKeys<T>): Promise<number | null>;
    updateWhere(where: ModelKeys<T>, setValues: ModelKeys<T>): Promise<number | null>;
    exists(params: T): Promise<boolean>;
    count(params: T): Promise<number>;
    delete(model: T | number): Promise<boolean>;
    deleteWhere<T>(inputs: T): Promise<boolean>;
    refresh(model: T): Promise<T | undefined>;
    attach(model: T, relation: string, payload: number | string | Array<number | string> | Record<string, any>): Promise<void>;
    sync(model: T, relation: string, payload: any[]): Promise<void>;
    chunk(where: T, size: number, cb: (models: T[]) => void): Promise<void>;
    raiseError(): void;
    query<R = T>(): CustomQueryBuilder<T, R>;
    getEntityName(): string;
    updateAndReturn(where: T, setValues: ModelKeys<T>): Promise<T | T[]>;
    bulkInsert(inputs: ModelKeys<T>[]): Promise<T[]>;
}
