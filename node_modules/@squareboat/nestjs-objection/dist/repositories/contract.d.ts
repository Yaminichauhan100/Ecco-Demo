import { BaseModel } from "../baseModel";
import { ModelKeys } from "../interfaces";
export interface RepositoryContract<T extends BaseModel> {
    model: any;
    all(inputs?: T): Promise<T[]>;
    firstWhere(inputs: ModelKeys<T>, error?: boolean): Promise<T | undefined>;
    getWhere(inputs: ModelKeys<T>, error?: boolean): Promise<T[]>;
    create(inputs: ModelKeys<T>): Promise<T>;
    createOrUpdate(conditions: ModelKeys<T>, values: ModelKeys<T>): Promise<T | undefined>;
    firstOrNew(conditions: ModelKeys<T>, values: ModelKeys<T>): Promise<T>;
    update(model: T, setValues: ModelKeys<T>): Promise<number | null>;
    updateWhere(where: ModelKeys<T>, setValues: ModelKeys<T>): Promise<number | null>;
    exists(params: T): Promise<boolean>;
    count(params: T): Promise<number>;
    refresh(model: T): Promise<T | undefined>;
    delete(model: T): Promise<boolean>;
    deleteWhere(params: ModelKeys<T>): Promise<boolean>;
    attach(model: T, relation: string, payload: number | string | Array<number | string> | Record<string, any>): Promise<void>;
    sync(model: T, relation: string, payload: any[]): Promise<void>;
    chunk(where: T, size: number, cb: (models: T[]) => void): Promise<void>;
    raiseError(): void;
    query(): any;
    updateAndReturn(where: T, setValues: ModelKeys<T>, returnOne?: boolean): Promise<T | T[]>;
    bulkInsert(inputs: ModelKeys<T>[]): Promise<T[]>;
}
