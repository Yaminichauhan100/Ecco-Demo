"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleIO = void 0;
const argumentParser_1 = require("./argumentParser");
const inquirer_1 = require("./inquirer");
const logger_1 = require("./logger");
class ConsoleIO {
    constructor(schemaString, argv) {
        this.schemaString = schemaString;
        this.argv = argv;
        this.values = { arguments: {}, options: {} };
        this.schema = { name: "", arguments: [], options: [], meta: { desc: "" } };
        this.values = { arguments: {}, options: {} };
        this.rawValues = Object.assign({}, this.argv);
        this.missingArguments = [];
        this.hasErrors = false;
    }
    static from(schemaString, argv) {
        const parent = new ConsoleIO(schemaString, argv);
        parent.handle();
        return parent;
    }
    argument(key) {
        return this.values.arguments[key];
    }
    option(key) {
        return this.values.options[key];
    }
    handle() {
        this.schema = argumentParser_1.ArgumentParser.from(this.schemaString);
        this.values = { arguments: {}, options: {} };
        this.rawValues = Object.assign({}, this.argv);
        const argumentValues = this.argv._.splice(1);
        for (const argument of this.schema.arguments) {
            if (argument.isArray && argumentValues.length > 0) {
                this.values.arguments[argument.name] = argumentValues;
                break;
            }
            else {
                const singleArgumentValue = argumentValues.splice(0, 1);
                if (singleArgumentValue.length > 0) {
                    this.values.arguments[argument.name] = singleArgumentValue[0];
                }
            }
            if (!this.values.arguments[argument.name]) {
                if (argument.defaultValue !== "secret_default_value") {
                    this.values.arguments[argument.name] = argument.isArray
                        ? [argument.defaultValue]
                        : argument.defaultValue;
                }
            }
        }
        this.validateArguments();
        if (this.hasErrors)
            return this;
        for (const option of this.schema.options) {
            const value = this.argv[option.name];
            if (value) {
                this.values.options[option.name] = value;
            }
            else {
                this.values.options[option.name] = option.defaultValue;
            }
        }
        return this;
    }
    validateArguments() {
        for (const argument of this.schema.arguments) {
            if (!this.values.arguments[argument.name] && argument.isRequired) {
                this.missingArguments.push(argument.name);
            }
        }
        if (this.missingArguments.length > 0) {
            this.hasErrors = true;
        }
    }
    info(msg) {
        logger_1.Logger.info(msg);
    }
    error(msg) {
        logger_1.Logger.error(msg);
    }
    success(msg) {
        logger_1.Logger.success(msg);
    }
    line() {
        logger_1.Logger.line();
    }
    table(rows) {
        logger_1.Logger.table(rows);
    }
    ask(question) {
        return __awaiter(this, void 0, void 0, function* () {
            return inquirer_1.Inquirer.ask(question);
        });
    }
    select(question, choices, multiple = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return inquirer_1.Inquirer.select(question, choices, multiple);
        });
    }
    confirm(question) {
        return __awaiter(this, void 0, void 0, function* () {
            return inquirer_1.Inquirer.confirm(question);
        });
    }
    password(question, mask = "") {
        return __awaiter(this, void 0, void 0, function* () {
            return inquirer_1.Inquirer.password(question, mask);
        });
    }
}
exports.ConsoleIO = ConsoleIO;
